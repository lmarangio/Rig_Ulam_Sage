"""
Functions to assemble Ulam matrices.
"""

from __future__ import division
from partition import equispaced, check_partition, is_iterable, hat_control_points
from integrals import integrate_hat_product
from quintic_basis import phi,psi,phi_prime,phi_second,psi_prime,phi_circ_T,phi_circ_T_prime,phi_circ_T_second,tau,tau_prime,func_prod_dyn_unquotiented,func_prod_dyn,func_prod,func_prod_second 

from rigorous_integral import rigorous_integral_C1,rigorous_integral_C2
from compute_coefficients_C2 import computing_coefficient_phi_phi

from assemblers_linear_response import assemble_on_branch_C2_pointwise_quintic_preserve_integral, assemble_on_branch_Liverani_basis_preserve_integral
from assembler_C0_cubic import assemble_on_branch_C1_pointwise_cubic_preserve_integral

from sage.rings.real_mpfr import RealField
from sage.all import RealNumber, NaN, floor
from sage.rings.real_mpfi import RealIntervalField, is_RealIntervalFieldElement
from sage.matrix.matrix_space import MatrixSpace
from joblib import Parallel, delayed
import sys

from sage.all import load
load('binsearch.spyx')


__all__ = ["assemble", "assemble_hat_integrals"]

	
def intersector(a, b, partition):
	"""
	Compute the lengths of the intersections of ``[a,b]`` with each interval of the partition.
	
	Returns a pair ``(ii, values)``, where ``values[i] =`` :math:`|I_{ii[i]} \cup [a,b]|`.
	Each entry in ``values`` is affected by an error at most ``fa.absolute_diameter()+fb.absolute_diameter()``.
	Assumes that the partition is already sorted increasingly.
	"""
	
	# ensure that they are "sorted"
	A = a.min(b)
	B = a.max(b)
	
	# interval.lower() and upper() are converted to floats with the right rounding mode automatically
	imin = binsearch(A.lower(), partition)
	imax = binsearch(B.upper(), partition)
	
	intervalfield = a.parent()
	
	ii = range(imin, imax+1)
	values = [NaN] * len(ii)
	for i in range(len(ii)):
		x = intervalfield(partition[ii[i]])
		y = intervalfield(partition[ii[i]+1])
		# lower and upper bounds for intersection
		lower = A.max(x)
		upper = B.min(y)
		values[i] = (upper - lower).max(0) / (y-x)
	return (ii, values)

def assemble_on_branch_ulam(dynamic, branch, partition, epsilon, prec = 53):
	r"""
	Compute a Ulam matrix discretizing ``dynamic`` on one of its monotonicity intervals (``branch``).
	
	See :fun:`assemble()` for details.
	"""
	
	# we'll see later if something more optimized is needed
	interval_field = RealIntervalField(prec=prec)
	M = MatrixSpace(interval_field, len(partition)-1, len(partition)-1, sparse = True)
	P = M(0)
	preimage_lower = dynamic.preimage(partition[0], branch, epsilon/2)
	
	sys.stdout.write("Assembling...")
	sys.stdout.flush()
	for i in range(len(partition)-1):
		preimage_upper = dynamic.preimage(partition[i+1], branch, epsilon/2)
		(jj, values) = intersector(preimage_lower, preimage_upper, partition)
		for j in range(len(jj)):
			P[i, jj[j]] = values[j]
		preimage_lower = preimage_upper
		if i>0 and i % 1024 == 0:
			sys.stdout.write("%d..." % i)
			sys.stdout.flush()
	
	sys.stdout.write("done.\n")
	sys.stdout.flush()
	return P

def assemble(dynamic, partition, basis='Ulam', epsilon=1e-10, prec = 53, n_jobs=1, do_check_partition=True):
	r"""
	Compute a Ulam matrix discretizing ``dynamic``.
	
	Each entry :math:`P_{ij}` is approximated up to an absolute error :math:`\frac{\varepsilon}{|I_i|}` or lower.
	
	Args:
		n_jobs (int): number of parallel jobs (default: 1, do not parallelize)
		basis (string): 'Ulam' or 'hat' (basis to use, Ulam intervals or hat functions)
		partition (int or sequence): if it is an integer, it is expanded to equispaced(partition) (see :func:`equispaced`)

	Returns: 
		P (Sage interval matrix): the discretized operator with rigorous inclusion intervals.
	
	Note:	In the current implementation, we keep track of errors in the arithmetic of the partition points explicitly as well.
	"""
	
	if not is_iterable(partition):
		partition = equispaced(partition)
		partition_was_autogenerated = True
	else:
		partition_was_autogenerated = False
	
	if do_check_partition and not partition_was_autogenerated:
		sys.stdout.write("Checking partition (disable with check_partition=False)...")
		sys.stdout.flush()
		check_partition(partition)
		sys.stdout.write("done.\n")
		sys.stdout.flush()

	Rdown = RealField(prec = prec, rnd = 'RNDD', sci_not = True)
	
	# The real error is the sum of the errors on all the monotonicity intervals, so we have to divide here
	domain_epsilon = Rdown(epsilon) / dynamic.nbranches
	
	if basis == 'Ulam' or basis == 'ulam':
		internal_function = assemble_on_branch_ulam
	elif basis == 'hat':
		internal_function = assemble_on_branch_hat
	else:
		if basis == 'hat':
			internal_function = assemble_on_branch_hat
		elif basis== 'C2spline':
			internal_function = assemble_on_branch_C2_torus_2_partsize
		elif basis== 'C0_spline_integral':
			internal_function = assemble_on_branch_C0_cubic_spline_integral
		elif basis== 'C2spline_integral':
			internal_function = assemble_on_branch_C2_torus_2_integral
		elif basis== 'C2spline_pointwise_preserve_integral':	
			internal_function = assemble_on_branch_C2_torus_2_pointwise_preserve_integral
		elif basis== 'C2spline_pointwise_preserve_integral_finer_derivatives':	
			internal_function = assemble_on_branch_C2_torus_2_pointwise_preserve_integral_finer_derivatives
		elif basis== 'Liverani_basis':
			internal_function = assemble_on_branch_Liverani_basis
		elif basis== 'Liverani_basis_preserve_integral':
			internal_function = assemble_on_branch_Liverani_basis_preserve_integral
		elif basis== 'Linear_quintic_preserve_integral':
			internal_function = assemble_on_branch_C2_pointwise_quintic_preserve_integral
		elif basis== 'Linear_cubic_preserve_integral':
			internal_function = assemble_on_branch_C1_pointwise_cubic_preserve_integral		
		else:
			raise ValueError, "Unknown basis kind"
	
	if n_jobs>1:
		sys.stdout.write("Spawning parallel processes.\n")
		sys.stdout.flush()
	
	results = Parallel(n_jobs=n_jobs)(delayed(internal_function)(dynamic, i, partition, domain_epsilon, prec = prec) for i in range(dynamic.nbranches))
	
	sys.stdout.write("Summing matrices on the function branches...")
	sys.stdout.flush()
	S = sum(results)
	sys.stdout.write("done.\n")
	sys.stdout.flush()
	return S

def hat(x, i, partition):
	"""
	Evaluates a hat function on the torus.

	Returns :math:`\phi(x)`, where :math:`\phi` is the piecewise linear function which satisfies:
	* :math:`\phi(x)=0` for :math:`x\leq partition[i-1]`
	* :math:`\phi(partition[i])=1`
	* :math:`\phi(x)=0` for :math:`x\geq partition[i+1]`

	The cases `i==0` and `i==len(partition)-1` (peaks in 0 and 1) are handled in a slightly different way.
	"""

	intervalfield = x.parent()

	if i == 0:
		mi = intervalfield(partition[i])
		hi = intervalfield(partition[i+1])
		right_branch = (hi-x)/(hi-mi)
		return right_branch.max(0)
	if i == len(partition)-1:
		lo = intervalfield(partition[i-1])
		mi = intervalfield(partition[i])
		left_branch = (x-lo)/(mi-lo)
		return left_branch.max(0)
	
	lo = intervalfield(partition[i-1])
	mi = intervalfield(partition[i])
	hi = intervalfield(partition[i+1])
	left_branch = (x-lo)/(mi-lo)
	right_branch = (hi-x)/(hi-mi)
	return (left_branch.min(right_branch)).max(0)

def assemble_on_branch_hat(dynamic, branch, partition, epsilon, prec = 53):
	"""
	Compute a matrix discretizing ``dynamic`` using hat functions as basis.
	
	Assume that we are working on a torus, so there is no border and f(0)=f(1).
	
	See :fun:`assemble_C0()` for details.
	"""

	n = len(partition) - 1
	# we'll see later if something more optimized is needed
	M = MatrixSpace(RealIntervalField(prec=prec), n, n, sparse = True)
	P = M(0)
	
	sys.stdout.write("Assembling...")
	sys.stdout.flush()
	for i in range(n):
		y = dynamic.preimage(partition[i], branch, epsilon)
		Tprimey = dynamic.fprime(y).abs()
		# typically these two will be equal, unless the interval ``y`` contains a grid point.
		jmin = binsearch(y.lower(), partition)
		assert jmin>=0 and jmin < len(partition) #we have changed the behavior of binsearch, checking that these edge cases were unused
		jmax = binsearch(y.upper(), partition)
		assert jmin>=0 and jmin < len(partition) #we have changed the behavior of binsearch, checking that these edge cases were unused
		# phi_j(y) will be nonzero for j in [jmin, ..., jmax+1]
		# where jmax+1 may "overlap" to 0
		for j in range(jmin,jmax+2):
			# in each interval we have an increasing and a decreasing branch of a hat function
			P[i,(j%n)] += hat(y, j, partition) / Tprimey
		if j>0 and j % 1024 == 0:
			sys.stdout.write("%d..." % j)
			sys.stdout.flush()
	
	sys.stdout.write("done.\n")
	sys.stdout.flush()
	return P

def assemble_hat_integrals(dynamic, partition, prec=53):
	"""
	Compute a matrix discretizing ``dynamic`` using integrals of hat functions and a first-order approximation
	"""
	
	n = len(partition) - 1
	F = RealIntervalField(prec=prec)
	M = MatrixSpace(F, n, n, sparse = True)
	P = M(0)

	if not is_RealIntervalFieldElement(partition[0]):
		partition = [F(x) for x in partition]

	for j in range(n):
		if j>0 and j % 1024 == 0:
			sys.stdout.write("%d..." % j)
			sys.stdout.flush()
	
		x = partition[j]
		y = dynamic.f_unquotiented(x)
		yprime = dynamic.fprime(x)
		# we approximate :math:`L \varphi_j(x)` by taking a linearization of T, as in Sec 6.2 of [Galatolo, Nisoli]
		
		cj = hat_control_points(j, partition)
		# :math:`L\varphi_j(x)` is approximated by 1/yprime times the hat function with control points d
		d = (y + yprime * (cj[0] - cj[1]), y, y + yprime * (cj[2] - cj[1]))
		
		
		# ensure that the control points in d are increasing
		if d[2] < d[0]:
			d[0], d[2] = d[2], d[0]
		imin = binsearch(d[0].lower() - floor(d[0].lower()), partition)
		i = imin
		integer_shift = floor(d[0].lower())
		integral = float('inf')
		while integral != 0:
			phii = tuple(x + integer_shift for x in hat_control_points(i, partition))
			integral = integrate_hat_product(d, phii) / yprime / (1/2*(phii[2]-phii[0]))
			P[i,j] += integral
			i = i + 1
			if i == n:
				i = 0
				integer_shift += 1
	return P

def assemble_on_branch_C2_torus_2_partsize(dynamic, branch, partition, epsilon, prec = 53):
	"""
	Compute a matrix discretizing ``dynamic`` using piecewise cubic functions as basis.
	
	Assume that we are working on a torus, so there is no border and f(0)=f(1).
	
	See :fun:`assemble_piecewise_cubic_spline()` for details.
	"""

	n = len(partition)-1
	# we'll see later if something more optimized is needed
	M = MatrixSpace(RealIntervalField(prec=prec), 2*n,2*n, sparse = True)
	P = M(0)
	
	sys.stdout.write("Assembling...")
	sys.stdout.flush()
	for i in range(n):
		y = dynamic.preimage(partition[i], branch, epsilon)
		
		Tprimey = dynamic.fprime(y).abs()
		Tsecondy = dynamic.fsecond(y).abs()
		# typically these two will be equal, unless the interval ``y`` contains a grid point.
		jmin = binsearch(y.lower(), partition)
		assert jmin>=0 and jmin < len(partition) #we have changed the behavior of binsearch, checking that these edge cases were unused
		jmax = binsearch(y.upper(), partition)
		assert jmin>=0 and jmin < len(partition) #we have changed the behavior of binsearch, checking that these edge cases were unused
		# phi_j(y) will be nonzero for j in [jmin, ..., jmax+1]
		# where jmax+1 may "overlap" to 0
		
		for j in range(jmin,jmax+2):
			# in each interval we have the partition of unity
			# we keep track of it and its derivative 
			# please note that, if we change this evaluation for the integrals,
			# we obtain a discretization that preserves integrals.
			P[i,(j%n)] += phi(y, j, n) / Tprimey
			P[i,(j%n)+n] += psi(y, j, n) /Tprimey
			
			#and the basis for the derivative
			P[i+n,(j%n)] += phi_prime(y,j,n)/(Tprimey**2)-phi(y,j,n)*Tsecondy /(Tprimey**3)
			P[i+n,(j%n)+n] += psi_prime(y,j,n)/(Tprimey**2)-psi(y,j,n)*Tsecondy /(Tprimey**3)
			if j>0 and j % 1024 == 0:
				sys.stdout.write("%d..." % j)
				sys.stdout.flush()
		
	sys.stdout.write("done.\n")
	sys.stdout.flush()
	return P


def assemble_on_branch_C2_torus_2_pointwise_preserve_integral(dynamic, branch, partition, epsilon, prec = 53):
	"""
	Compute a matrix discretizing ``dynamic`` using piecewise cubic functions as basis.
	
	Assume that we are working on a torus, so there is no border and f(0)=f(1).
	
	See :fun:`assemble_piecewise_cubic_spline()` for details.
	"""
	
	n = len(partition)-1
	# we'll see later if something more optimized is needed
	
	F = RealIntervalField(prec=prec)
	M = MatrixSpace(F, 2*n+1, 2*n+1, sparse = True)
	P = M(0)
		
	sys.stdout.write("Assembling...")
	sys.stdout.flush()
	for i in range(n):
		
		y = dynamic.preimage(partition[i], branch, epsilon)
		Real_Interval=y.parent()
		
		Tprimey = dynamic.fprime(y)
		Tsecondy = dynamic.fsecond(y)
		# typically these two will be equal, unless the interval ``y`` contains a grid point.
		jmin = binsearch(y.lower(), partition)
		jmax = binsearch(y.upper(), partition)

		# phi_j(y) will be nonzero for j in [jmin, ..., jmax+1]
		# where jmax+1 may "overlap" to 0
		
		val=tau(y,n)/Tprimey
		P[i,2*n]+=val
		P[2*n,2*n]-= val/n
		
		P[i+n,2*n] += tau_prime(y,n)/(Tprimey**2)-tau(y,n)*Tsecondy /(Tprimey**3)
		
			
		for j in range(jmin,jmax+2):
			# in each interval we have the partition of unity
			# we keep track of it and its derivative 
			# please note that, if we change this evaluation for the integrals,
			# we obtain a discretization that preserves integrals.
			val=phi(y, j, n) / Tprimey
			P[i,(j%n)] += val
			P[2*n,(j%n)]-= val/n
			
			val=psi(y, j, n) /Tprimey
			P[i,(j%n)+n] += val
			P[2*n,(j%n)+n]-= val/n
			
			#and the basis for the derivative
			P[i+n,(j%n)] += phi_prime(y,j,n)/(Tprimey**2)-phi(y,j,n)*Tsecondy /(Tprimey**3)
			P[i+n,(j%n)+n] += psi_prime(y,j,n)/(Tprimey**2)-psi(y,j,n)*Tsecondy /(Tprimey**3)
			if j>0 and j % 1024 == 0:
				sys.stdout.write("%d..." % j)
				sys.stdout.flush()
	
	if branch==0:
		P[2*n,2*n]+=1
		for j in range(n):
			#print(j)
			P[2*n,j]+=1/n
	
	sys.stdout.write("done.\n")
	sys.stdout.flush()
	return P


def assemble_on_branch_C2_torus_2_pointwise_preserve_integral_finer_derivatives(dynamic, branch, partition, epsilon, prec = 53):
	"""
	Compute a matrix discretizing ``dynamic`` using piecewise cubic functions as basis.
	
	Assume that we are working on a torus, so there is no border and f(0)=f(1).
	
	See :fun:`assemble_piecewise_cubic_spline()` for details.
	"""
	
	n = len(partition)-1
	# we'll see later if something more optimized is needed
	
	partition1=equispaced(n)
	partition2=equispaced(n**2)
	
	F = RealIntervalField(prec=prec)
	M = MatrixSpace(F, n+n**2+1, n+n**2+1, sparse = True)
	P = M(0)
		
	sys.stdout.write("Assembling...")
	sys.stdout.flush()
	for i in range(n):
		
		y = dynamic.preimage(partition[i], branch, epsilon)
		Real_Interval=y.parent()
		
		Tprimey = dynamic.fprime(y).abs()
		Tsecondy = dynamic.fsecond(y).abs()
		# typically these two will be equal, unless the interval ``y`` contains a grid point.
		jmin = binsearch(y.lower(), partition)
		jmax = binsearch(y.upper(), partition)
		# phi_j(y) will be nonzero for j in [jmin, ..., jmax+1]
		# where jmax+1 may "overlap" to 0
		
		val=tau(y,n)/Tprimey
		P[i,2*n]+=val
		P[2*n,2*n]-= val/n
		
		
		for j in range(jmin,jmax+2):
			# in each interval we have the partition of unity
			# we keep track of it and its derivative 
			# please note that, if we change this evaluation for the integrals,
			# we obtain a discretization that preserves integrals.
			val=phi(y, j, n) / Tprimey
			P[i,(j%n)] += val
			P[2*n,(j%n)]-= val/n
			
			for l in range(finer):
				val=psi(y,j*finer+l, n*finer) /Tprimey
				P[i,((j*finer+l)%(n*finer))+n] += val
				P[2*n,((j*finer+l)%(n*finer))+n]-= val/n
	
	for i in range(finer*n):

		y = dynamic.preimage(Real_Interval(i)/(finer*n), branch, epsilon)
		
		Tprimey = dynamic.fprime(y).abs()
		Tsecondy = dynamic.fsecond(y).abs()
		# typically these two will be equal, unless the interval ``y`` contains a grid point.
		jmin = binsearch(y.lower(), partition)
		jmax = binsearch(y.upper(), partition)
		
		for j in range(jmin,jmax+2):
			# in each interval we have the partition of unity
			# we keep track of it and its derivative 
			# please note that, if we change this evaluation for the integrals,
			# we obtain a discretization that preserves integrals.
			
			for l in range(finer):
				P[i+n,((j*finer+l)%(n*finer))+n] += psi_prime(y,j*finer+l, n*finer)/(Tprimey**2)-psi(y,j*finer+l, n*finer)*Tsecondy /(Tprimey**3)
			
			P[i+n,(j%n)] += phi_prime(y,j,n)/(Tprimey**2)-phi(y,j,n)*Tsecondy /(Tprimey**3)
			P[i+n,2*n] += tau_prime(y,n)/(Tprimey**2)-tau(y,n)*Tsecondy /(Tprimey**3)
	
	if j>0 and j % 1024 == 0:
			sys.stdout.write("%d..." % j)
			sys.stdout.flush()
		
	
	if branch==0:
		P[2*n,2*n]+=1
		for j in range(n):
			#print(j)
			P[2*n,j]+=1/n
	
	sys.stdout.write("done.\n")
	sys.stdout.flush()
	return P




def assemble_on_branch_C2_torus_2_integral(dynamic, branch, partition, epsilon, prec = 53):
	"""
	Compute a matrix discretizing ``dynamic`` using piecewise cubic functions as basis.
	
	Assume that we are working on a torus, so there is no border and f(0)=f(1).
	
	See :fun:`assemble_piecewise_cubic_spline()` for details.
	"""

	n = len(partition)-1
	width=2**(-20)
	# we'll see later if something more optimized is needed
	M = MatrixSpace(RealIntervalField(prec=prec), 2*n,2*n, sparse = True)
	P = M(0)
	
	sys.stdout.write("Assembling...")
	sys.stdout.flush()
	for i in range(n):
		y = dynamic.preimage(partition[i], branch, epsilon)
		Interval_Field = y.parent()
		
		Tprimey = dynamic.fprime(y).abs()
		Tsecondy = dynamic.fsecond(y).abs()
		# typically these two will be equal, unless the interval ``y`` contains a grid point.
		jmin = max(binsearch(y.lower(), partition)-3,0)
		assert jmin>=0 and jmin < len(partition) #we have changed the behavior of binsearch, checking that these edge cases were unused
		jmax = min(binsearch(y.upper(), partition)+3,n-1)
		assert jmin>=0 and jmin < len(partition) #we have changed the behavior of binsearch, checking that these edge cases were unused

		# phi_j(y) will be nonzero for j in [jmin, ..., jmax+1]
		# where jmax+1 may "overlap" to 0
		
		for j in range(jmin,jmax):
			# in each interval we have the partition of unity
			# we keep track of it and its derivative 
			# please note that, if we change this evaluation for the integrals,
			# we obtain a discretization that preserves integrals.
			domain=Interval_Field(j-1,j+1)/n
			# phi_i(T(x))\cdot \phi_j
			"""
			f,f_prime=func_prod_dyn(lambda x:phi(x,i,n),lambda x:phi_prime(x,i,n),lambda x:phi(x,j,n),lambda x:phi_prime(x,j,n),dynamic)
			P[i,(j%n)] += rigorous_integral_C1(f,f_prime,domain,width,iteration_count=0)
			"""
			f,f_prime=func_prod(lambda x:phi_circ_T(x,i,n,dynamic),lambda x:phi_circ_T_prime(x,i,n,dynamic),lambda x:phi(x,j,n),lambda x:phi_prime(x,j,n))
			P[i,(j%n)] += n*rigorous_integral_C1(f,f_prime,domain,width,iteration_count=0)
			#print("phi",i,j)
			#print(P[i,(j%n)])
			"""
			f,f_prime=func_prod_dyn_unquotiented(lambda x:phi(x,i,n),lambda x:phi_prime(x,i,n),lambda x:psi(x,j+branch*n,n),lambda x:psi_prime(x,j+branch*n,n),dynamic)
			P[i,(j%n)+n] += rigorous_integral_C1(f,f_prime,domain,width,iteration_count=0)
			"""
			f,f_prime=func_prod(lambda x:phi_circ_T(x,i,n,dynamic),lambda x:phi_circ_T_prime(x,i,n,dynamic),lambda x:psi(x,j,n),lambda x:psi_prime(x,j,n))
			P[i,(j%n)+n] += n*rigorous_integral_C1(f,f_prime,domain,width,iteration_count=0)
			#print("psi",i,j)
			#print(P[i,(j%n)+n])
			#and the basis for the derivative
			P[i+n,(j%n)] += phi_prime(y,j,n)/(Tprimey**2)-phi(y,j,n)*Tsecondy /(Tprimey**3)
			P[i+n,(j%n)+n] += psi_prime(y,j,n)/(Tprimey**2)-psi(y,j,n)*Tsecondy /(Tprimey**3)
			if j>0 and j % 1024 == 0:
				sys.stdout.write("%d..." % j)
				sys.stdout.flush()
		
	sys.stdout.write("done.\n")
	sys.stdout.flush()
	return P

def assemble_on_branch_C0_cubic_spline_integral(dynamic, branch, partition, epsilon, prec = 53):
	"""
	Compute a matrix discretizing ``dynamic`` using hat functions as basis.
	
	Assume that we are working on a torus, so there is no border and f(0)=f(1).
	
	See :fun:`assemble_C0()` for details.
	"""
	step=5
	width=2**(-50)
	n = len(partition) - 1
	# we'll see later if something more optimized is needed
	M = MatrixSpace(RealIntervalField(prec=prec), n, n, sparse = True)
	P = M(0)
	#V= VectorSpace(RealIntervalField(prec=prec), n)
	
	sys.stdout.write("Assembling...")
	sys.stdout.flush()
	for i in range(n):
		if (i%16==0): 
			print (i)
		y = dynamic.preimage(partition[i], branch, epsilon)
		Interval_Field=y.parent()
		Tprimey = dynamic.fprime(y).abs()
		# typically these two will be equal, unless the interval ``y`` contains a grid point.
		jmin = binsearch(y.lower(), partition)
		assert jmin>=0 and jmin < len(partition) #we have changed the behavior of binsearch, checking that these edge cases were unused
		jmax = binsearch(y.upper(), partition)
		assert jmin>=0 and jmin < len(partition) #we have changed the behavior of binsearch, checking that these edge cases were unused
		
		# phi_j(y) will be nonzero for j in [jmin, ..., jmax+1]
		# where jmax+1 may "overlap" to 0
		for j in range(jmin-1,jmax+2):
			domain=Interval_Field(j-1,j+1)/n
			#f,f_prime,f_second=func_prod_second(lambda x:phi_circ_T(x,i,n,dynamic),lambda x:phi_circ_T_prime(x,i,n,dynamic),lambda x:phi_circ_T_second(x,i,n,dynamic),\
			#							lambda x:phi(x,j,n),lambda x:phi_prime(x,j,n),lambda x:phi_second(x,j,n))
			#P[i,(j%n)] += n*rigorous_integral_C2(f,f_prime,f_second,domain,width,iteration_count=0)
			P[i,(j%n)] +=n*computing_coefficient_phi_phi(i,j,n,domain,dynamic,step,width)
			#print((P[i,(j%n)]).absolute_diameter())
		if j>0 and j % 1024 == 0:
			sys.stdout.write("%d..." % j)
			sys.stdout.flush()
	
	sys.stdout.write("done.\n")
	sys.stdout.flush()
	return P
